Object Class:-> 
-> the most commonly required methods for every java class(whether it is predefined class or customizer 
class) are defined in a separate class which is nothing but Object class.

-> every class in java is the child class of Object either directly or indirectly so that Object class
methods by default available to every java class.hence Object class is considered as root of all java 
classes.

Note:->
-> if our class doesn't extend any other class then only our class is the direct child class of Object.
example:->
class A {
}
here A is a child of Object

-> if our class extends any other class then our class is indirect child class of Object.
class A extends B{
}
here A is child of B and B is a child of Object means it forms multilevel inheritance.

Conclusion:-> either directly or indirectly java won't provide support for multiple inheritance with 
respect to classes.

-> object class defines the following 11 methods 
i.public String toString()
ii.public native int hashCode()
iii.public boolean equals(Object o)
iv.protected native Object clone() throws CloneNotSupportedException
v.protected void finalize() throws Throwable
vi.public final Class getClass()
vii.public final void wait() throws InterruptedException
viii.public final native void wait(long ms) throws InterruptedException
ix.public final void wait(long ms,int ns) throws InterruptedException
x.public native final void notify()
xi.public native final void notifyAll()

Note:-> Strictly speaking Object class contains 12 methods.the extra method is registerNatives.
private static native void registerNatives();
this method internally required for Object class and not available to the child classes.hence we are not
required to consider this method.

toString Method:-> we can use toString method to get string representation of an object.
String s = obj.toString();
whenever we are trying to print object reference internally toString method will be called.
Student s = new Student();
sysout(s) => sysout(s.toString());

if our class doesn't contain toString method then Object class toString method will be executed.
Example:-> public class Student {
	
	String name;
	int roll;
	
	Student(String name,int roll){
		this.name = name;
		this.roll = roll;
	}

	public static void main(String[] args) {
		
		Student s = new Student("mahesh",101);
		Student s2 = new Student("pawan",102);
		System.out.println(s);
		System.out.println(s.toString());

	}

}

Output:-> 
com.lamichane.toString.method.Student@515f550a
com.lamichane.toString.method.Student@515f550a

Object class toString method implementation for above output:-> in the above example Object class
toString method got executed which is implemented as follows.
public String toString(){
	return getClass.getName() + "@" + Integer.toHexString(hashCode());
}

Note:-> Based on our requriement we can override toString method to provide our own string representation
for example,whenever we are trying to print employee object reference to print his name and roll no we 
have to override toString method as follows:->

public class Employee {
	
	String name;
	int roll;
	
	Employee(String name,int roll){
		this.name = name;
		this.roll = roll;
	}
	
	public String toString() {
		return "[ Name = "+name+", Roll = "+roll+"]";
	}
	
	public static void main(String[] args) {
		
		Employee e1 = new Employee("sangeet",201);
		Employee e2 = new Employee("nirman",202);
		
		System.out.println(e1);
		System.out.println(e2);

	}

}

Output:->
[ Name = sangeet, Roll = 201]
[ Name = nirman, Roll = 202]


Example2:->
public class Test2 {

	public static void main(String[] args) {
		
		String s = new String("mahesh");
		Integer i = new Integer(10);
		List list = new ArrayList();
		list.add("hero");
		list.add("zero");
		Test2 t = new Test2();
		
		System.out.println(s);
		System.out.println(i);
		System.out.println(list);
		System.out.println(t);

	}

}

Output:->
mahesh
10
[hero, zero]
com.lamichane.toString.method.Test2@626b2d4a



in all wrapper classe,in all collection classes,string class,stringbuffer,stringbuilder classes toString
method is overidden for meaningful string representation hence it is highly recomended to override 
toString() method in our class also.


hashCode Method:-> 
-> for every object a unique number generated by JVM which is nothing but hashcode.
-> hashcode won't represents address of object.
-> JVM will use hashcode while saving object into hashing related data structures like hashtable,
hashmap,hashset etc.
-> the main advantage of saving objects based on hashcode is search operation will become easy(the most
powerful search algorithm upto today is hashing).
-> if you are giving a chance to object class hashcode method it will generate hashcode based on address
of the object.it doesn't mean hashcode represents address of the object.
-> based on our requirement we can override hashcode method in our class to generate our own hashcode.
-> during generating hashcode by JVM,JVM performs some algorithms on the address of the object.
-> overriding hashcode method is said to be proper if and only if for every object we have to generate 
a unique number as hashcode.
class Student {
	public int hashCode(){
		return 100;
	}
}
this is improper way of overriding hashcode method becasuse for all student objects we are generating 
same no as hashcode.

class Student{
	public int hashCode(){
		return rollno;
	}
}
this is proper way of overriding hashcode method because we are generating a different hashcode for every
object.

toString vs hashCode:->
-> if we are giving the chance to Object class toString method it will internally calls hashCode method.
-> if we are toString method then our toString method may not call hashCode method.

public class RelationBetweenHashCodeToStringMethod {
	
	int i;
	RelationBetweenHashCodeToStringMethod(int i){
		this.i = i;
	}
	
	public int  hashCode() {
		return i;
	}

	public static void main(String[] args) {
		 
		RelationBetweenHashCodeToStringMethod obj1 = new RelationBetweenHashCodeToStringMethod(10);
		RelationBetweenHashCodeToStringMethod obj2 = new RelationBetweenHashCodeToStringMethod(100);
		System.out.println(obj1);
		System.out.println(obj2);

	}

}

Output:->
com.lamichhane.hashCode.method.RelationBetweenHashCodeToStringMethod@a
com.lamichhane.hashCode.method.RelationBetweenHashCodeToStringMethod@64

Note:-> this output is always same it doesn't matter how many time you execute the program.if you
override both toString and hashCode method then override hasCode method never be executed.


equals method:-> 
-> we can use equals method to check equality of two objects.
Example:
obj1.equals(obj2)
-> if our class doesn't contains equals method then object class equals method will be executed.


































































